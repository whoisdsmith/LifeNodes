/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LinkerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// linker/readModeLinker.ts
var import_obsidian2 = require("obsidian");

// linker/linkerCache.ts
var import_obsidian = require("obsidian");
var PrefixNode = class {
  constructor() {
    this.children = /* @__PURE__ */ new Map();
    this.files = /* @__PURE__ */ new Set();
    this.charValue = "";
    this.value = "";
  }
};
var MatchNode = class {
  constructor() {
    this.start = 0;
    this.length = 0;
    this.files = /* @__PURE__ */ new Set();
    this.value = "";
  }
  get end() {
    return this.start + this.length;
  }
};
var PrefixTree = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
    this.root = new PrefixNode();
    this._currentNodes = [];
    this.updateTree();
  }
  getCurrentMatchNodes(index) {
    const matchNodes = [];
    for (const node of this._currentNodes) {
      if (node.files.size === 0) {
        continue;
      }
      const matchNode = new MatchNode();
      matchNode.length = node.value.length;
      matchNode.start = index - matchNode.length;
      matchNode.files = node.files;
      matchNode.value = node.value;
      matchNodes.push(matchNode);
    }
    matchNodes.sort((a, b) => b.length - a.length);
    return matchNodes;
  }
  addFile(name, file) {
    let node = this.root;
    for (let char of name) {
      let child = node.children.get(char);
      if (!child) {
        child = new PrefixNode();
        child.parent = node;
        child.charValue = char;
        child.value = node.value + char;
        node.children.set(char, child);
      }
      node = child;
    }
    node.files.add(file);
  }
  updateTree() {
    var _a, _b, _c;
    this.root = new PrefixNode();
    const includeAllFiles = this.settings.includeAllFiles || this.settings.linkerDirectories.length === 0;
    const includeDirPattern = new RegExp(`(^|/)(${this.settings.linkerDirectories.join("|")})/`);
    for (const file of this.app.vault.getMarkdownFiles()) {
      const tags = ((_a = (0, import_obsidian.getAllTags)(this.app.metadataCache.getFileCache(file))) != null ? _a : []).filter((tag) => tag.trim().length > 0).map((tag) => tag.startsWith("#") ? tag.slice(1) : tag);
      const includeFile = tags.includes(this.settings.tagToIncludeFile);
      const excludeFile = tags.includes(this.settings.tagToExcludeFile);
      if (excludeFile) {
        continue;
      }
      if (!includeFile && !includeAllFiles && !includeDirPattern.test(file.path)) {
        continue;
      }
      const metadata = this.app.metadataCache.getFileCache(file);
      const aliases = (_c = (_b = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _b.aliases) != null ? _c : [];
      let names = [file.basename];
      if (aliases) {
        names.push(...aliases);
      }
      names = names.filter((name) => name && name.trim().length > 0);
      if (this.settings.matchCaseSensitive) {
        if (tags.includes(this.settings.tagToIgnoreCase)) {
          const lowerCaseNames = names.map((name) => name.toLowerCase());
          names.push(...lowerCaseNames);
        }
      } else {
        if (!tags.includes(this.settings.tagToMatchCase)) {
          const lowerCaseNames = names.map((name) => name.toLowerCase());
          names.push(...lowerCaseNames);
        }
      }
      for (const name of names) {
        this.addFile(name, file);
      }
    }
  }
  findFiles(prefix) {
    let node = this.root;
    for (const char of prefix) {
      node = node.children.get(char.toLowerCase());
      if (!node) {
        return /* @__PURE__ */ new Set();
      }
    }
    return node.files;
  }
  resetSearch() {
    this._currentNodes = [this.root];
  }
  pushChar(char) {
    const newNodes = [];
    const chars = [char];
    if (!this.settings.matchCaseSensitive) {
      chars.push(char.toLowerCase());
    }
    chars.forEach((c) => {
      if (!this.settings.matchOnlyWholeWords || PrefixTree.checkWordBoundary(c)) {
        newNodes.push(this.root);
      }
      for (const node of this._currentNodes) {
        const child = node.children.get(c);
        if (child) {
          if (!newNodes.includes(child)) {
            newNodes.push(child);
          }
        }
      }
    });
    this._currentNodes = newNodes;
  }
  static checkWordBoundary(char) {
    const pattern = /[\/\n\t\r\s,.!"`Â´()\[\]'{}|~\p{Emoji_Presentation}\p{Extended_Pictographic}]/u;
    return pattern.test(char);
  }
};
var LinkerCache = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
    const { vault } = app;
    this.vault = vault;
    this.cache = new PrefixTree(app, settings);
    this.updateCache(true);
  }
  reset() {
    this.cache.resetSearch();
  }
  updateCache(force = false) {
    var _a, _b, _c;
    if (!((_b = (_a = this.app) == null ? void 0 : _a.workspace) == null ? void 0 : _b.getActiveFile())) {
      return;
    }
    const activeFile = (_c = this.app.workspace.getActiveFile()) == null ? void 0 : _c.path;
    if (activeFile === this.activeFilePath && !force) {
      return;
    }
    this.cache.updateTree();
    this.activeFilePath = activeFile;
  }
};

// linker/readModeLinker.ts
var GlossaryLinker = class extends import_obsidian2.MarkdownRenderChild {
  constructor(app, settings, context, containerEl) {
    super(containerEl);
    this.settings = settings;
    this.app = app;
    this.ctx = context;
    this.linkerCache = new LinkerCache(app, settings);
    this.load();
  }
  getClosestLinkPath(glossaryName) {
    var _a, _b;
    const destName = this.ctx.sourcePath.replace(/(.*).md/, "$1");
    let currentDestName = destName;
    let currentPath = this.app.metadataCache.getFirstLinkpathDest((0, import_obsidian2.getLinkpath)(glossaryName), currentDestName);
    if (currentPath == null)
      return null;
    while (currentDestName.includes("/")) {
      currentDestName = currentDestName.replace(/\/[^\/]*?$/, "");
      const newPath = this.app.metadataCache.getFirstLinkpathDest((0, import_obsidian2.getLinkpath)(glossaryName), currentDestName);
      if ((((_a = newPath == null ? void 0 : newPath.path) == null ? void 0 : _a.length) || 0) > ((_b = currentPath == null ? void 0 : currentPath.path) == null ? void 0 : _b.length)) {
        currentPath = newPath;
        console.log("Break at New path: ", currentPath);
        break;
      }
    }
    return currentPath;
  }
  onload() {
    var _a, _b, _c, _d;
    const tags = ["p", "li", "td", "th", "span", "em", "strong"];
    if (this.settings.includeHeaders) {
      tags.push("h1", "h2", "h3", "h4", "h5", "h6");
    }
    for (const tag of tags) {
      const nodeList = this.containerEl.getElementsByTagName(tag);
      const children = this.containerEl.children;
      for (let index = 0; index <= nodeList.length; index++) {
        const item = index == nodeList.length ? this.containerEl : nodeList.item(index);
        for (let childNodeIndex = 0; childNodeIndex < item.childNodes.length; childNodeIndex++) {
          const childNode = item.childNodes[childNodeIndex];
          if (childNode.nodeType === Node.TEXT_NODE) {
            let text = childNode.textContent || "";
            if (text.length === 0)
              continue;
            this.linkerCache.reset();
            const additions = [];
            let id = 0;
            for (let i = 0; i <= text.length; i) {
              const codePoint = text.codePointAt(i);
              const char = i < text.length ? String.fromCodePoint(codePoint) : "\n";
              const isWordBoundary = PrefixTree.checkWordBoundary(char);
              if (!this.settings.matchOnlyWholeWords || isWordBoundary) {
                const currentNodes = this.linkerCache.cache.getCurrentMatchNodes(i);
                if (currentNodes.length > 0) {
                  const node = currentNodes[0];
                  const nFrom = node.start;
                  const nTo = node.end;
                  const name = text.slice(nFrom, nTo);
                  const file = node.files.values().next().value;
                  additions.push({
                    id: id++,
                    from: nFrom,
                    to: nTo,
                    text: name,
                    file,
                    isSubWord: !isWordBoundary
                  });
                }
              }
              this.linkerCache.cache.pushChar(char);
              i += char.length;
            }
            additions.sort((a, b) => {
              if (a.from === b.from) {
                return b.to - a.to;
              }
              return a.from - b.from;
            });
            const filteredAdditions = [];
            const additionsToDelete = /* @__PURE__ */ new Map();
            for (let i = 0; i < additions.length; i++) {
              const addition = additions[i];
              for (let j = i + 1; j < additions.length; j++) {
                const otherAddition = additions[j];
                if (otherAddition.from >= addition.to) {
                  break;
                }
                additionsToDelete.set(otherAddition.id, true);
              }
            }
            for (const addition of additions) {
              if (!additionsToDelete.has(addition.id)) {
                filteredAdditions.push(addition);
              }
            }
            const parent = childNode.parentElement;
            let lastTo = 0;
            for (let addition of filteredAdditions) {
              const destName = this.ctx.sourcePath.replace(/(.*).md/, "$1");
              const linkpath = addition.file.path;
              const replacementText = addition.text;
              let span = document.createElement("span");
              span.classList.add("glossary-entry", "virtual-link");
              if (this.settings.applyDefaultLinkStyling) {
                span.classList.add("virtual-link-default");
              }
              let link = this.containerEl.createEl("a");
              link.text = `${replacementText}`;
              link.href = `${linkpath}`;
              link.setAttribute("data-href", `${linkpath}`);
              link.classList.add("internal-link");
              link.classList.add("virtual-link-a");
              link.target = "_blank";
              link.rel = "noopener";
              span.appendChild(link);
              if (((_b = (_a = this.settings.glossarySuffix) == null ? void 0 : _a.length) != null ? _b : 0) > 0) {
                if (((_d = (_c = this.settings.glossarySuffix) == null ? void 0 : _c.length) != null ? _d : 0) > 0) {
                  if (!addition.isSubWord || !this.settings.suppressSuffixForSubWords) {
                    let icon = document.createElement("sup");
                    icon.textContent = this.settings.glossarySuffix;
                    icon.classList.add("linker-suffix-icon");
                    span.appendChild(icon);
                  }
                }
              }
              if (addition.from > 0) {
                parent == null ? void 0 : parent.insertBefore(document.createTextNode(text.slice(lastTo, addition.from)), childNode);
              }
              parent == null ? void 0 : parent.insertBefore(span, childNode);
              lastTo = addition.to;
            }
            const textLength = text.length;
            if (lastTo < textLength) {
              parent == null ? void 0 : parent.insertBefore(document.createTextNode(text.slice(lastTo)), childNode);
            }
            parent == null ? void 0 : parent.removeChild(childNode);
            childNodeIndex += 1;
          }
        }
      }
    }
  }
};

// linker/liveLinker.ts
var import_language = require("@codemirror/language");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");

// node_modules/@flatten-js/interval-tree/dist/main.mjs
var Interval = class Interval2 {
  constructor(low, high) {
    this.low = low;
    this.high = high;
  }
  clone() {
    return new Interval2(this.low, this.high);
  }
  get max() {
    return this.clone();
  }
  less_than(other_interval) {
    return this.low < other_interval.low || this.low === other_interval.low && this.high < other_interval.high;
  }
  equal_to(other_interval) {
    return this.low === other_interval.low && this.high === other_interval.high;
  }
  intersect(other_interval) {
    return !this.not_intersect(other_interval);
  }
  not_intersect(other_interval) {
    return this.high < other_interval.low || other_interval.high < this.low;
  }
  merge(other_interval) {
    return new Interval2(this.low === void 0 ? other_interval.low : this.low < other_interval.low ? this.low : other_interval.low, this.high === void 0 ? other_interval.high : this.high > other_interval.high ? this.high : other_interval.high);
  }
  output() {
    return [this.low, this.high];
  }
  static comparable_max(interval1, interval2) {
    return interval1.merge(interval2);
  }
  static comparable_less_than(val1, val2) {
    return val1 < val2;
  }
};
var RB_TREE_COLOR_RED = 0;
var RB_TREE_COLOR_BLACK = 1;
var Node2 = class {
  constructor(key = void 0, value = void 0, left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {
    this.left = left;
    this.right = right;
    this.parent = parent;
    this.color = color;
    this.item = { key, value };
    if (key && key instanceof Array && key.length === 2) {
      if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {
        let [low, high] = key;
        if (low > high)
          [low, high] = [high, low];
        this.item.key = new Interval(low, high);
      }
    }
    this.max = this.item.key ? this.item.key.max : void 0;
  }
  isNil() {
    return this.item.key === void 0 && this.item.value === void 0 && this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK;
  }
  _value_less_than(other_node) {
    return this.item.value && other_node.item.value && this.item.value.less_than ? this.item.value.less_than(other_node.item.value) : this.item.value < other_node.item.value;
  }
  less_than(other_node) {
    if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {
      return this.item.key.less_than(other_node.item.key);
    } else {
      return this.item.key.less_than(other_node.item.key) || this.item.key.equal_to(other_node.item.key) && this._value_less_than(other_node);
    }
  }
  _value_equal(other_node) {
    return this.item.value && other_node.item.value && this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) : this.item.value === other_node.item.value;
  }
  equal_to(other_node) {
    if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {
      return this.item.key.equal_to(other_node.item.key);
    } else {
      return this.item.key.equal_to(other_node.item.key) && this._value_equal(other_node);
    }
  }
  intersect(other_node) {
    return this.item.key.intersect(other_node.item.key);
  }
  copy_data(other_node) {
    this.item.key = other_node.item.key;
    this.item.value = other_node.item.value;
  }
  update_max() {
    this.max = this.item.key ? this.item.key.max : void 0;
    if (this.right && this.right.max) {
      const comparable_max = this.item.key.constructor.comparable_max;
      this.max = comparable_max(this.max, this.right.max);
    }
    if (this.left && this.left.max) {
      const comparable_max = this.item.key.constructor.comparable_max;
      this.max = comparable_max(this.max, this.left.max);
    }
  }
  not_intersect_left_subtree(search_node) {
    const comparable_less_than = this.item.key.constructor.comparable_less_than;
    let high = this.left.max.high !== void 0 ? this.left.max.high : this.left.max;
    return comparable_less_than(high, search_node.item.key.low);
  }
  not_intersect_right_subtree(search_node) {
    const comparable_less_than = this.item.key.constructor.comparable_less_than;
    let low = this.right.max.low !== void 0 ? this.right.max.low : this.right.item.key.low;
    return comparable_less_than(search_node.item.key.high, low);
  }
};
var IntervalTree = class {
  constructor() {
    this.root = null;
    this.nil_node = new Node2();
  }
  get size() {
    let count = 0;
    this.tree_walk(this.root, () => count++);
    return count;
  }
  get keys() {
    let res = [];
    this.tree_walk(this.root, (node) => res.push(node.item.key.output ? node.item.key.output() : node.item.key));
    return res;
  }
  get values() {
    let res = [];
    this.tree_walk(this.root, (node) => res.push(node.item.value));
    return res;
  }
  get items() {
    let res = [];
    this.tree_walk(this.root, (node) => res.push({
      key: node.item.key.output ? node.item.key.output() : node.item.key,
      value: node.item.value
    }));
    return res;
  }
  isEmpty() {
    return this.root == null || this.root === this.nil_node;
  }
  clear() {
    this.root = null;
  }
  insert(key, value = key) {
    if (key === void 0)
      return;
    let insert_node = new Node2(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);
    this.tree_insert(insert_node);
    this.recalc_max(insert_node);
    return insert_node;
  }
  exist(key, value = key) {
    let search_node = new Node2(key, value);
    return !!this.tree_search(this.root, search_node);
  }
  remove(key, value = key) {
    let search_node = new Node2(key, value);
    let delete_node = this.tree_search(this.root, search_node);
    if (delete_node) {
      this.tree_delete(delete_node);
    }
    return delete_node;
  }
  search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {
    let search_node = new Node2(interval);
    let resp_nodes = [];
    this.tree_search_interval(this.root, search_node, resp_nodes);
    return resp_nodes.map((node) => outputMapperFn(node.item.value, node.item.key));
  }
  intersect_any(interval) {
    let search_node = new Node2(interval);
    return this.tree_find_any_interval(this.root, search_node);
  }
  forEach(visitor) {
    this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));
  }
  map(callback) {
    const tree = new IntervalTree();
    this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));
    return tree;
  }
  *iterate(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {
    let node;
    if (interval) {
      node = this.tree_search_nearest_forward(this.root, new Node2(interval));
    } else if (this.root) {
      node = this.local_minimum(this.root);
    }
    while (node) {
      yield outputMapperFn(node.item.value, node.item.key);
      node = this.tree_successor(node);
    }
  }
  recalc_max(node) {
    let node_current = node;
    while (node_current.parent != null) {
      node_current.parent.update_max();
      node_current = node_current.parent;
    }
  }
  tree_insert(insert_node) {
    let current_node = this.root;
    let parent_node = null;
    if (this.root == null || this.root === this.nil_node) {
      this.root = insert_node;
    } else {
      while (current_node !== this.nil_node) {
        parent_node = current_node;
        if (insert_node.less_than(current_node)) {
          current_node = current_node.left;
        } else {
          current_node = current_node.right;
        }
      }
      insert_node.parent = parent_node;
      if (insert_node.less_than(parent_node)) {
        parent_node.left = insert_node;
      } else {
        parent_node.right = insert_node;
      }
    }
    this.insert_fixup(insert_node);
  }
  insert_fixup(insert_node) {
    let current_node;
    let uncle_node;
    current_node = insert_node;
    while (current_node !== this.root && current_node.parent.color === RB_TREE_COLOR_RED) {
      if (current_node.parent === current_node.parent.parent.left) {
        uncle_node = current_node.parent.parent.right;
        if (uncle_node.color === RB_TREE_COLOR_RED) {
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          uncle_node.color = RB_TREE_COLOR_BLACK;
          current_node.parent.parent.color = RB_TREE_COLOR_RED;
          current_node = current_node.parent.parent;
        } else {
          if (current_node === current_node.parent.right) {
            current_node = current_node.parent;
            this.rotate_left(current_node);
          }
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          current_node.parent.parent.color = RB_TREE_COLOR_RED;
          this.rotate_right(current_node.parent.parent);
        }
      } else {
        uncle_node = current_node.parent.parent.left;
        if (uncle_node.color === RB_TREE_COLOR_RED) {
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          uncle_node.color = RB_TREE_COLOR_BLACK;
          current_node.parent.parent.color = RB_TREE_COLOR_RED;
          current_node = current_node.parent.parent;
        } else {
          if (current_node === current_node.parent.left) {
            current_node = current_node.parent;
            this.rotate_right(current_node);
          }
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          current_node.parent.parent.color = RB_TREE_COLOR_RED;
          this.rotate_left(current_node.parent.parent);
        }
      }
    }
    this.root.color = RB_TREE_COLOR_BLACK;
  }
  tree_delete(delete_node) {
    let cut_node;
    let fix_node;
    if (delete_node.left === this.nil_node || delete_node.right === this.nil_node) {
      cut_node = delete_node;
    } else {
      cut_node = this.tree_successor(delete_node);
    }
    if (cut_node.left !== this.nil_node) {
      fix_node = cut_node.left;
    } else {
      fix_node = cut_node.right;
    }
    fix_node.parent = cut_node.parent;
    if (cut_node === this.root) {
      this.root = fix_node;
    } else {
      if (cut_node === cut_node.parent.left) {
        cut_node.parent.left = fix_node;
      } else {
        cut_node.parent.right = fix_node;
      }
      cut_node.parent.update_max();
    }
    this.recalc_max(fix_node);
    if (cut_node !== delete_node) {
      delete_node.copy_data(cut_node);
      delete_node.update_max();
      this.recalc_max(delete_node);
    }
    if (cut_node.color === RB_TREE_COLOR_BLACK) {
      this.delete_fixup(fix_node);
    }
  }
  delete_fixup(fix_node) {
    let current_node = fix_node;
    let brother_node;
    while (current_node !== this.root && current_node.parent != null && current_node.color === RB_TREE_COLOR_BLACK) {
      if (current_node === current_node.parent.left) {
        brother_node = current_node.parent.right;
        if (brother_node.color === RB_TREE_COLOR_RED) {
          brother_node.color = RB_TREE_COLOR_BLACK;
          current_node.parent.color = RB_TREE_COLOR_RED;
          this.rotate_left(current_node.parent);
          brother_node = current_node.parent.right;
        }
        if (brother_node.left.color === RB_TREE_COLOR_BLACK && brother_node.right.color === RB_TREE_COLOR_BLACK) {
          brother_node.color = RB_TREE_COLOR_RED;
          current_node = current_node.parent;
        } else {
          if (brother_node.right.color === RB_TREE_COLOR_BLACK) {
            brother_node.color = RB_TREE_COLOR_RED;
            brother_node.left.color = RB_TREE_COLOR_BLACK;
            this.rotate_right(brother_node);
            brother_node = current_node.parent.right;
          }
          brother_node.color = current_node.parent.color;
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          brother_node.right.color = RB_TREE_COLOR_BLACK;
          this.rotate_left(current_node.parent);
          current_node = this.root;
        }
      } else {
        brother_node = current_node.parent.left;
        if (brother_node.color === RB_TREE_COLOR_RED) {
          brother_node.color = RB_TREE_COLOR_BLACK;
          current_node.parent.color = RB_TREE_COLOR_RED;
          this.rotate_right(current_node.parent);
          brother_node = current_node.parent.left;
        }
        if (brother_node.left.color === RB_TREE_COLOR_BLACK && brother_node.right.color === RB_TREE_COLOR_BLACK) {
          brother_node.color = RB_TREE_COLOR_RED;
          current_node = current_node.parent;
        } else {
          if (brother_node.left.color === RB_TREE_COLOR_BLACK) {
            brother_node.color = RB_TREE_COLOR_RED;
            brother_node.right.color = RB_TREE_COLOR_BLACK;
            this.rotate_left(brother_node);
            brother_node = current_node.parent.left;
          }
          brother_node.color = current_node.parent.color;
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          brother_node.left.color = RB_TREE_COLOR_BLACK;
          this.rotate_right(current_node.parent);
          current_node = this.root;
        }
      }
    }
    current_node.color = RB_TREE_COLOR_BLACK;
  }
  tree_search(node, search_node) {
    if (node == null || node === this.nil_node)
      return void 0;
    if (search_node.equal_to(node)) {
      return node;
    }
    if (search_node.less_than(node)) {
      return this.tree_search(node.left, search_node);
    } else {
      return this.tree_search(node.right, search_node);
    }
  }
  tree_search_nearest_forward(node, search_node) {
    let best;
    let curr = node;
    while (curr && curr !== this.nil_node) {
      if (curr.less_than(search_node)) {
        if (curr.intersect(search_node)) {
          best = curr;
          curr = curr.left;
        } else {
          curr = curr.right;
        }
      } else {
        if (!best || curr.less_than(best))
          best = curr;
        curr = curr.left;
      }
    }
    return best || null;
  }
  tree_search_interval(node, search_node, res) {
    if (node != null && node !== this.nil_node) {
      if (node.left !== this.nil_node && !node.not_intersect_left_subtree(search_node)) {
        this.tree_search_interval(node.left, search_node, res);
      }
      if (node.intersect(search_node)) {
        res.push(node);
      }
      if (node.right !== this.nil_node && !node.not_intersect_right_subtree(search_node)) {
        this.tree_search_interval(node.right, search_node, res);
      }
    }
  }
  tree_find_any_interval(node, search_node) {
    let found = false;
    if (node != null && node !== this.nil_node) {
      if (node.left !== this.nil_node && !node.not_intersect_left_subtree(search_node)) {
        found = this.tree_find_any_interval(node.left, search_node);
      }
      if (!found) {
        found = node.intersect(search_node);
      }
      if (!found && node.right !== this.nil_node && !node.not_intersect_right_subtree(search_node)) {
        found = this.tree_find_any_interval(node.right, search_node);
      }
    }
    return found;
  }
  local_minimum(node) {
    let node_min = node;
    while (node_min.left != null && node_min.left !== this.nil_node) {
      node_min = node_min.left;
    }
    return node_min;
  }
  local_maximum(node) {
    let node_max = node;
    while (node_max.right != null && node_max.right !== this.nil_node) {
      node_max = node_max.right;
    }
    return node_max;
  }
  tree_successor(node) {
    let node_successor;
    let current_node;
    let parent_node;
    if (node.right !== this.nil_node) {
      node_successor = this.local_minimum(node.right);
    } else {
      current_node = node;
      parent_node = node.parent;
      while (parent_node != null && parent_node.right === current_node) {
        current_node = parent_node;
        parent_node = parent_node.parent;
      }
      node_successor = parent_node;
    }
    return node_successor;
  }
  rotate_left(x) {
    let y = x.right;
    x.right = y.left;
    if (y.left !== this.nil_node) {
      y.left.parent = x;
    }
    y.parent = x.parent;
    if (x === this.root) {
      this.root = y;
    } else {
      if (x === x.parent.left) {
        x.parent.left = y;
      } else {
        x.parent.right = y;
      }
    }
    y.left = x;
    x.parent = y;
    if (x != null && x !== this.nil_node) {
      x.update_max();
    }
    y = x.parent;
    if (y != null && y !== this.nil_node) {
      y.update_max();
    }
  }
  rotate_right(y) {
    let x = y.left;
    y.left = x.right;
    if (x.right !== this.nil_node) {
      x.right.parent = y;
    }
    x.parent = y.parent;
    if (y === this.root) {
      this.root = x;
    } else {
      if (y === y.parent.left) {
        y.parent.left = x;
      } else {
        y.parent.right = x;
      }
    }
    x.right = y;
    y.parent = x;
    if (y !== null && y !== this.nil_node) {
      y.update_max();
    }
    x = y.parent;
    if (x != null && x !== this.nil_node) {
      x.update_max();
    }
  }
  tree_walk(node, action) {
    if (node != null && node !== this.nil_node) {
      this.tree_walk(node.left, action);
      action(node);
      this.tree_walk(node.right, action);
    }
  }
  testRedBlackProperty() {
    let res = true;
    this.tree_walk(this.root, function(node) {
      if (node.color === RB_TREE_COLOR_RED) {
        if (!(node.left.color === RB_TREE_COLOR_BLACK && node.right.color === RB_TREE_COLOR_BLACK)) {
          res = false;
        }
      }
    });
    return res;
  }
  testBlackHeightProperty(node) {
    let height = 0;
    let heightLeft = 0;
    let heightRight = 0;
    if (node.color === RB_TREE_COLOR_BLACK) {
      height++;
    }
    if (node.left !== this.nil_node) {
      heightLeft = this.testBlackHeightProperty(node.left);
    } else {
      heightLeft = 1;
    }
    if (node.right !== this.nil_node) {
      heightRight = this.testBlackHeightProperty(node.right);
    } else {
      heightRight = 1;
    }
    if (heightLeft !== heightRight) {
      throw new Error("Red-black height property violated");
    }
    height += heightLeft;
    return height;
  }
};

// linker/liveLinker.ts
var LiveLinkWidget = class extends import_view.WidgetType {
  constructor(text, linkFile, from, to, isSubWord, app, settings) {
    super();
    this.text = text;
    this.linkFile = linkFile;
    this.from = from;
    this.to = to;
    this.isSubWord = isSubWord;
    this.app = app;
    this.settings = settings;
  }
  createInternalLinkSpan() {
    var _a, _b;
    const note = this.linkFile;
    const linkText = this.text;
    let linkHref = "";
    try {
      linkHref = note.path;
    } catch (e) {
      console.error(e);
    }
    const span = document.createElement("span");
    const link = document.createElement("a");
    link.href = linkHref;
    link.textContent = linkText;
    link.target = "_blank";
    link.rel = "noopener noreferrer";
    link.setAttribute("from", this.from.toString());
    link.setAttribute("to", this.to.toString());
    link.setAttribute("origin-text", this.text);
    link.classList.add("internal-link", "virtual-link-a");
    span.classList.add("glossary-entry", "virtual-link");
    if (this.settings.applyDefaultLinkStyling) {
      span.classList.add("virtual-link-default");
    }
    span.appendChild(link);
    if (((_b = (_a = this.settings.glossarySuffix) == null ? void 0 : _a.length) != null ? _b : 0) > 0) {
      if (!this.isSubWord || !this.settings.suppressSuffixForSubWords) {
        let icon = document.createElement("sup");
        icon.textContent = this.settings.glossarySuffix;
        icon.classList.add("linker-suffix-icon");
        span.appendChild(icon);
      }
    }
    return span;
  }
  toDOM(view) {
    const div = this.createInternalLinkSpan();
    return div;
  }
};
var AutoLinkerPlugin = class {
  constructor(view, app, settings) {
    this.lastCursorPos = 0;
    this.lastActiveFile = "";
    this.app = app;
    this.settings = settings;
    const { vault } = this.app;
    this.vault = vault;
    this.linkerCache = new LinkerCache(app, this.settings);
    this.decorations = this.buildDecorations(view);
  }
  update(update) {
    var _a;
    const cursorPos = update.view.state.selection.main.from;
    const activeFile = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path;
    const fileChanged = activeFile != this.lastActiveFile;
    if (this.lastCursorPos != cursorPos || update.docChanged || fileChanged || update.viewportChanged) {
      this.lastCursorPos = cursorPos;
      this.linkerCache.updateCache();
      this.decorations = this.buildDecorations(update.view);
      this.lastActiveFile = activeFile != null ? activeFile : "";
    }
  }
  destroy() {
  }
  buildDecorations(view) {
    const builder = new import_state.RangeSetBuilder();
    for (let { from, to } of view.visibleRanges) {
      this.linkerCache.reset();
      const text = view.state.doc.sliceString(from, to);
      const additions = [];
      let id = 0;
      for (let i = 0; i <= text.length; i) {
        const codePoint = text.codePointAt(i);
        const char = i < text.length ? String.fromCodePoint(codePoint) : "\n";
        const isWordBoundary = PrefixTree.checkWordBoundary(char);
        if (!this.settings.matchOnlyWholeWords || isWordBoundary) {
          const currentNodes = this.linkerCache.cache.getCurrentMatchNodes(i);
          if (currentNodes.length > 0) {
            const node = currentNodes[0];
            const nFrom = node.start;
            const nTo = node.end;
            const name = text.slice(nFrom, nTo);
            const file = node.files.values().next().value;
            const aFrom = from + nFrom;
            const aTo = from + nTo;
            console.log(currentNodes, node.files);
            additions.push({
              id: id++,
              from: aFrom,
              to: aTo,
              widget: new LiveLinkWidget(name, file, aFrom, aTo, !isWordBoundary, this.app, this.settings)
            });
          }
        }
        this.linkerCache.cache.pushChar(char);
        i += char.length;
      }
      additions.sort((a, b) => {
        if (a.from === b.from) {
          return b.to - a.to;
        }
        return a.from - b.from;
      });
      const filteredAdditions = [];
      const additionsToDelete = /* @__PURE__ */ new Map();
      for (let i = 0; i < additions.length; i++) {
        const addition = additions[i];
        for (let j = i + 1; j < additions.length; j++) {
          const otherAddition = additions[j];
          if (otherAddition.from >= addition.to) {
            break;
          }
          additionsToDelete.set(otherAddition.id, true);
        }
      }
      for (const addition of additions) {
        if (!additionsToDelete.has(addition.id)) {
          filteredAdditions.push(addition);
        }
      }
      const excludedIntervalTree = new IntervalTree();
      const excludedTypes = [
        "codeblock",
        "code-block",
        "internal-link",
        "link"
      ];
      if (!this.settings.includeHeaders) {
        excludedTypes.push("header-");
      }
      (0, import_language.syntaxTree)(view.state).iterate({
        from,
        to,
        enter(node) {
          const type = node.type.name;
          for (const excludedType of excludedTypes) {
            if (type.contains(excludedType)) {
              excludedIntervalTree.insert([node.from, node.to]);
            }
          }
        }
      });
      const cursorPos = view.state.selection.main.from;
      filteredAdditions.forEach((addition) => {
        const [from2, to2] = [addition.from, addition.to];
        const overlaps = excludedIntervalTree.search([from2, to2]);
        const cursorNearby = cursorPos >= from2 - 0 && cursorPos <= to2 + 0;
        if (overlaps.length === 0 && !cursorNearby) {
          builder.add(from2, to2, import_view.Decoration.replace({
            widget: addition.widget
          }));
        }
      });
    }
    return builder.finish();
  }
};
var pluginSpec = {
  decorations: (value) => value.decorations
};
var liveLinkerPlugin = (app, settings) => {
  return import_view.ViewPlugin.define((editorView) => {
    return new AutoLinkerPlugin(editorView, app, settings);
  }, pluginSpec);
};

// main.ts
var DEFAULT_SETTINGS = {
  matchOnlyWholeWords: false,
  suppressSuffixForSubWords: false,
  includeAllFiles: true,
  linkerDirectories: ["Glossary"],
  glossarySuffix: "\u{1F517}",
  useMarkdownLinks: false,
  applyDefaultLinkStyling: true,
  includeHeaders: true,
  matchCaseSensitive: false,
  tagToIgnoreCase: "linker-ignore-case",
  tagToMatchCase: "linker-match-case",
  tagToExcludeFile: "linker-exclude",
  tagToIncludeFile: "linker-include"
};
var LinkerPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerMarkdownPostProcessor((element, context) => {
      context.addChild(new GlossaryLinker(this.app, this.settings, context, element));
    });
    this.registerEditorExtension(liveLinkerPlugin(this.app, this.settings));
    this.addSettingTab(new LinkerSettingTab(this.app, this));
    this.registerEvent(this.app.workspace.on("file-menu", (menu, file, source) => this.addContextMenuItem(menu, file, source)));
  }
  addContextMenuItem(menu, file, source) {
    const that = this;
    const app = this.app;
    const settings = this.settings;
    function contextMenuHandler(event) {
      const targetElement = event.target;
      if (targetElement instanceof HTMLElement && targetElement.classList.contains("virtual-link-a")) {
        menu.addItem((item) => {
          item.setTitle("[Virtual Linker] Convert to real link").setIcon("link").onClick(() => {
            var _a;
            const from = parseInt(targetElement.getAttribute("from") || "-1");
            const to = parseInt(targetElement.getAttribute("to") || "-1");
            const text = targetElement.getAttribute("origin-text") || "";
            const target = file;
            const activeFile = app.workspace.getActiveFile();
            const activeFilePath = activeFile == null ? void 0 : activeFile.path;
            let replacement = "";
            if (settings.useMarkdownLinks) {
              replacement = `[${text}](${target.path})`;
            } else {
              replacement = `[[${target.path}|${text}]]`;
            }
            if (!activeFile) {
              console.error("No active file");
              return;
            }
            const editor = (_a = app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView)) == null ? void 0 : _a.editor;
            const fromEditorPos = editor == null ? void 0 : editor.offsetToPos(from);
            const toEditorPos = editor == null ? void 0 : editor.offsetToPos(to);
            if (!fromEditorPos || !toEditorPos) {
              console.warn("No editor positions");
              return;
            }
            editor == null ? void 0 : editor.replaceRange(replacement, fromEditorPos, toEditorPos);
          });
        });
      }
      document.removeEventListener("contextmenu", contextMenuHandler);
    }
    document.addEventListener("contextmenu", contextMenuHandler, { once: true });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    const fileContent = await this.app.vault.adapter.read(this.app.vault.configDir + "/app.json");
    const appSettings = JSON.parse(fileContent);
    this.settings.useMarkdownLinks = appSettings.useMarkdownLinks;
  }
  async updateSettings(settings = {}) {
    Object.assign(this.settings, settings);
    await this.saveData(this.settings);
  }
};
var LinkerSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Matching behavior").setHeading();
    new import_obsidian3.Setting(containerEl).setName("Virtual link suffix").setDesc("The suffix to add to auto generated virtual links.").addText((text) => text.setValue(this.plugin.settings.glossarySuffix).onChange(async (value) => {
      await this.plugin.updateSettings({ glossarySuffix: value });
    }));
    new import_obsidian3.Setting(containerEl).setName("Case sensitive").setDesc("If activated, the matching is case sensitive.").addToggle((toggle) => toggle.setValue(this.plugin.settings.matchCaseSensitive).onChange(async (value) => {
      await this.plugin.updateSettings({ matchCaseSensitive: value });
      this.display();
    }));
    if (this.plugin.settings.matchCaseSensitive) {
      new import_obsidian3.Setting(containerEl).setName("Tag to ignore case").setDesc("By adding this tag to a file, the linker will ignore the case for the file.").addText((text) => text.setValue(this.plugin.settings.tagToIgnoreCase).onChange(async (value) => {
        await this.plugin.updateSettings({ tagToIgnoreCase: value });
      }));
    } else {
      new import_obsidian3.Setting(containerEl).setName("Tag to match case").setDesc("By adding this tag to a file, the linker will match the case for the file.").addText((text) => text.setValue(this.plugin.settings.tagToMatchCase).onChange(async (value) => {
        await this.plugin.updateSettings({ tagToMatchCase: value });
      }));
    }
    new import_obsidian3.Setting(containerEl).setName("Include headers").setDesc("If activated, headers (so your lines beginning with at least one `#`) are included for virtual links.").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeHeaders).onChange(async (value) => {
      await this.plugin.updateSettings({ includeHeaders: value });
    }));
    new import_obsidian3.Setting(containerEl).setName("Match only whole words").setDesc("If activated, only whole words are matched. Otherwise, every part of a word is found.").addToggle((toggle) => toggle.setValue(this.plugin.settings.matchOnlyWholeWords).onChange(async (value) => {
      await this.plugin.updateSettings({ matchOnlyWholeWords: value });
      this.display();
    }));
    if (!this.plugin.settings.matchOnlyWholeWords) {
      new import_obsidian3.Setting(containerEl).setName("Suppress suffix for sub words").setDesc("If activated, the suffix is not added to links for subwords, but only for complete matches.").addToggle((toggle) => toggle.setValue(this.plugin.settings.suppressSuffixForSubWords).onChange(async (value) => {
        await this.plugin.updateSettings({ suppressSuffixForSubWords: value });
      }));
    }
    new import_obsidian3.Setting(containerEl).setName("Matched files").setHeading();
    new import_obsidian3.Setting(containerEl).setName("Include all files").setDesc("Include all files for the virtual linker.").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeAllFiles).onChange(async (value) => {
      await this.plugin.updateSettings({ includeAllFiles: value });
      this.display();
    }));
    if (!this.plugin.settings.includeAllFiles) {
      new import_obsidian3.Setting(containerEl).setName("Glossary linker directories").setDesc("Directories to include for the virtual linker (separated by new lines).").addTextArea((text) => {
        let setValue = "";
        try {
          setValue = this.plugin.settings.linkerDirectories.join("\n");
        } catch (e) {
          console.warn(e);
        }
        text.setPlaceholder("List of directory names (separated by new line)").setValue(setValue).onChange(async (value) => {
          this.plugin.settings.linkerDirectories = value.split("\n").map((x) => x.trim()).filter((x) => x.length > 0);
          await this.plugin.updateSettings();
        });
        text.inputEl.addClass("linker-settings-text-box");
      });
    }
    if (!this.plugin.settings.includeAllFiles) {
      new import_obsidian3.Setting(containerEl).setName("Tag to include file").setDesc("Tag to explicitly include the file for the linker.").addText((text) => text.setValue(this.plugin.settings.tagToIncludeFile).onChange(async (value) => {
        await this.plugin.updateSettings({ tagToIncludeFile: value });
      }));
    }
    new import_obsidian3.Setting(containerEl).setName("Tag to ignore file").setDesc("Tag to ignore the file for the linker.").addText((text) => text.setValue(this.plugin.settings.tagToExcludeFile).onChange(async (value) => {
      await this.plugin.updateSettings({ tagToExcludeFile: value });
    }));
    new import_obsidian3.Setting(containerEl).setName("Link style").setHeading();
    new import_obsidian3.Setting(containerEl).setName("Apply default link styling").setDesc("If toggled, the default link styling will be applied to virtual links. Furthermore, you can style the links yourself with a CSS-snippet affecting the class `virtual-link`. (Find the CSS snippet directory at Appearance -> CSS Snippets -> Open snippets folder)").addToggle((toggle) => toggle.setValue(this.plugin.settings.applyDefaultLinkStyling).onChange(async (value) => {
      await this.plugin.updateSettings({ applyDefaultLinkStyling: value });
    }));
  }
};
