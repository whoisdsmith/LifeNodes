/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MemoryLanePlugin
});
module.exports = __toCommonJS(main_exports);

// views/MemoriesListView.ts
var import_obsidian2 = require("obsidian");

// utils/MemoryLaneUtils.ts
var import_obsidian = require("obsidian");
var MemoryLaneUtils = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = plugin.app;
  }
  async getNotesInFolder(folderPath, app) {
    const files = app.vault.getFiles();
    let filteredFiles = [];
    if (folderPath === "/") {
      filteredFiles = files.filter((file) => !file.path.includes("/"));
      console.log(filteredFiles);
    } else {
      filteredFiles = files.filter(
        (file) => file.path.startsWith(folderPath)
      );
    }
    return filteredFiles;
  }
  async getNotesInFolderWithLastModify(folderPath, lastModify, app) {
    const files = app.vault.getFiles();
    let filteredFiles = [];
    const lastModifyTime = lastModify.getTime();
    if (folderPath === "/") {
      filteredFiles = files.filter((file) => {
        return !file.path.includes("/") && file.stat.mtime >= lastModifyTime;
      });
    } else {
      filteredFiles = files.filter((file) => {
        return file.path.startsWith(folderPath) && file.stat.mtime >= lastModifyTime;
      });
    }
    return filteredFiles;
  }
  async filterNotesByTag(notes, tagName, app) {
    const taggedNotes = [];
    const dateRegex = /\b\d{4}-\d{2}-\d{2}\b/;
    for (const note of notes) {
      const fileContent = await app.vault.read(note);
      const fileCreateDate = new Date(note.stat.ctime).toISOString().split("T")[0];
      const rows = fileContent.split("\n");
      for (const row of rows) {
        if (row.includes(tagName)) {
          const rowCreateDateMatch = row.match(dateRegex);
          const rowCreateDate = rowCreateDateMatch ? rowCreateDateMatch[0] : fileCreateDate;
          taggedNotes.push({
            fileName: note.basename,
            fileCreateDate,
            contentNote: row,
            rowCreateDate,
            yearNote: rowCreateDate.substring(0, 4)
          });
        }
      }
    }
    taggedNotes.sort(
      (a, b) => a.rowCreateDate.localeCompare(b.rowCreateDate)
    );
    return taggedNotes;
  }
  async createOrGetFile(filePath, content = "") {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file) {
      console.log("File exists:", filePath);
      return file;
    }
    try {
      await this.app.vault.create(filePath, content);
      console.log("File created:", filePath);
      return this.app.vault.getAbstractFileByPath(filePath);
    } catch (error) {
      console.error("Error handling file:", error);
      return null;
    }
  }
  async createTimelineMarkdown(taggedNotes) {
    let markdownContent = "";
    let currentYear = "";
    console.log("taggedNotes");
    console.log(taggedNotes);
    taggedNotes.forEach((note) => {
      const noteYear = note.rowCreateDate.substring(0, 4);
      if (noteYear !== currentYear) {
        if (currentYear !== "") {
          markdownContent += "\n";
        }
        currentYear = noteYear;
        markdownContent += `> [!info] **${currentYear}**

`;
      }
      markdownContent += `> [!${note.rowCreateDate}]
`;
      markdownContent += `> ${note.contentNote}
`;
      markdownContent += `> <span class="right-align">[[${note.fileName}]]</span>

`;
    });
    return markdownContent;
  }
  async writeToMarkdownFile(filePath, content, app) {
    try {
      const file = app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian.TFile) {
        await app.vault.modify(file, content);
      } else {
        await app.vault.create(filePath, content);
      }
    } catch (error) {
      console.error("Error writing to Markdown file:", error);
    }
  }
  async getMemoriesFromPast() {
    const notesInFolder = await this.getNotesInFolder(
      this.plugin.settings.folderPath,
      this.app
    );
    console.log(notesInFolder);
    const taggedNotes = await this.filterNotesByTag(
      notesInFolder,
      this.plugin.settings.tagName,
      this.app
    );
    return taggedNotes;
  }
  async searchNotes(searchText) {
    const lowerCaseSearchText = searchText.trim().toLowerCase();
    const notes = await this.getMemoriesFromPast();
    const filteredNotes = notes.filter(
      (note) => {
        var _a;
        return (_a = note.contentNote) == null ? void 0 : _a.toLowerCase().includes(lowerCaseSearchText);
      }
    );
    return filteredNotes;
  }
  async findFirstNoteByRowContent(notes, searchContent) {
    return notes.find((note) => note.rowContent.includes(searchContent));
  }
  async processFileContent(dbManager, fileNote, fileContent, hashtag, filePath) {
    const newLines = fileContent.split("\n");
    const lsNoteofFile = await dbManager.getNotesByFilePath(filePath);
    newLines.forEach((content, index) => {
      const existingData = lsNoteofFile.find((note) => note.rowContent === content);
      const idFileIndex = existingData == null ? void 0 : existingData.id;
      console.log("idFileIndex", idFileIndex);
      console.log("hashtag", hashtag);
      if (content.includes(hashtag)) {
        if (!existingData || existingData.rowContent !== content) {
          const lineId = idFileIndex || this.generateUniqueId();
          const modifiedDate = new Date(fileNote.stat.mtime);
          const noteRowData = {
            id: lineId,
            path: filePath,
            fileName: filePath.split("/").pop() || "",
            fileCreatedDate: new Date(fileNote.stat.ctime),
            fileModifyDate: modifiedDate,
            rowId: "",
            rowContent: content,
            rowCreatedDate: modifiedDate,
            rowYear: modifiedDate.getFullYear().toString(),
            createdDate: new Date(),
            updatedDate: new Date(),
            filePath,
            dateNo: this.getMMDD(modifiedDate)
          };
          dbManager.updateRow(noteRowData);
        }
      } else if (existingData) {
        if (idFileIndex) {
          dbManager.deleteRow(idFileIndex);
        }
      }
    });
  }
  generateUniqueId() {
    return Number.parseInt(Date.now() + Math.random().toString(16).slice(2));
  }
  getMMDD(date) {
    const mm = date.getMonth() + 1;
    const dd = date.getDate();
    return [mm, dd].join("-");
  }
  groupNotesByYear(notes) {
    return notes.reduce((acc, note) => {
      if (!acc[note.rowYear]) {
        acc[note.rowYear] = [];
      }
      acc[note.rowYear].push(note);
      return acc;
    }, {});
  }
  sortGroupedNotes(groupedNotes) {
    const sortedGroupedNotes = {};
    const sortedYears = Object.keys(groupedNotes).sort().reverse();
    sortedYears.forEach((year) => {
      const sortedNotes = groupedNotes[year].sort((a, b) => a.createdDate.getTime() - b.createdDate.getTime());
      sortedGroupedNotes[year] = sortedNotes;
    });
    return sortedGroupedNotes;
  }
  formatDate(date, format) {
    const tokens = {
      "yyyy": () => date.getFullYear().toString(),
      "MM": () => (date.getMonth() + 1).toString().padStart(2, "0"),
      "dd": () => date.getDate().toString().padStart(2, "0"),
      "HH": () => date.getHours().toString().padStart(2, "0"),
      "mm": () => date.getMinutes().toString().padStart(2, "0"),
      "ss": () => date.getSeconds().toString().padStart(2, "0")
    };
    return format.replace(/yyyy|MM|dd|HH|mm|ss/g, (match) => tokens[match]());
  }
};

// data/IndexedDBManager.ts
var DATABASSE_VERSION = 1;
var DATABASE_NAME = "memorylane-database";
var TABLE_FOLDER_TIME_INDEX = "folder-time-index";
var TABLE_NOTES = "notes";
var IndexedDBManager = class {
  constructor() {
    this.dbName = DATABASE_NAME;
    this.dbVersion = DATABASSE_VERSION;
  }
  async openDatabase() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      request.onupgradeneeded = (event) => {
        const db = request.result;
        if (!db.objectStoreNames.contains(TABLE_NOTES)) {
          const objectStore = db.createObjectStore(TABLE_NOTES, { autoIncrement: true });
          objectStore.createIndex("filePath", "filePath", { unique: false });
          objectStore.createIndex("dateNo", "dateNo", { unique: false });
        }
        if (!db.objectStoreNames.contains(TABLE_FOLDER_TIME_INDEX)) {
          const objectStore = db.createObjectStore(TABLE_FOLDER_TIME_INDEX, { autoIncrement: true });
          objectStore.createIndex("folderPath", "folderPath", { unique: false });
          objectStore.createIndex("hashtag", "hashtag", { unique: false });
        }
      };
      request.onsuccess = (event) => {
        this.db = request.result;
        resolve();
      };
      request.onerror = (event) => {
        reject(request.error);
      };
    });
  }
  async addRow(rowData) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(TABLE_NOTES, "readwrite");
      const store = transaction.objectStore(TABLE_NOTES);
      const request = store.add(rowData);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  async getRow(id) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(TABLE_NOTES, "readonly");
      const store = transaction.objectStore(TABLE_NOTES);
      const request = store.get(id);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  async getAllData(rowValue, sortDirection) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(TABLE_NOTES, "readonly");
      const store = transaction.objectStore(TABLE_NOTES);
      const request = store.openCursor();
      const data = [];
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          if (!rowValue || cursor.value.rowContent.includes(rowValue)) {
            data.push(cursor.value);
          }
          cursor.continue();
        } else {
          const sortedData = data.sort((a, b) => {
            const dateA = new Date(a.rowCreatedDate).getTime();
            const dateB = new Date(b.rowCreatedDate).getTime();
            return sortDirection === "asc" ? dateA - dateB : dateB - dateA;
          });
          resolve(sortedData);
        }
      };
      request.onerror = () => {
        reject(request.error);
      };
    });
  }
  async getNotesByFilePath(filePath) {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      request.onsuccess = (event) => {
        const db = event.target.result;
        const transaction = db.transaction(TABLE_NOTES, "readonly");
        const store = transaction.objectStore(TABLE_NOTES);
        const index = store.index("filePath");
        const query = index.getAll(filePath);
        query.onsuccess = () => {
          resolve(query.result);
        };
        query.onerror = (event2) => {
          console.error("Query error:", event2.target.error);
          reject(event2.target.error);
        };
      };
      request.onerror = () => {
        reject(request.error);
      };
    });
  }
  async updateRow(rowData) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(TABLE_NOTES, "readwrite");
      const store = transaction.objectStore(TABLE_NOTES);
      const request = store.put(rowData);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  async deleteRow(id) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(TABLE_NOTES, "readwrite");
      const store = transaction.objectStore(TABLE_NOTES);
      const request = store.delete(id);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  async getFolderLastModify(folderPath, hashtag) {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      request.onerror = (event) => {
        console.error("Database error:", event.target.error);
        reject(event.target.error);
      };
      request.onsuccess = (event) => {
        const db = event.target.result;
        const transaction = db.transaction(TABLE_FOLDER_TIME_INDEX, "readonly");
        const store = transaction.objectStore(TABLE_FOLDER_TIME_INDEX);
        try {
          const index = store.index("folderPath");
          const query = index.getAll(folderPath);
          query.onsuccess = () => {
            const filteredResults = query.result.filter((item) => item.hashtag === hashtag);
            const result = filteredResults.length > 0 ? filteredResults[0] : null;
            resolve(result);
          };
          query.onerror = (event2) => {
            console.error("Query error:", event2.target.error);
            reject(event2.target.error);
          };
        } catch (error) {
          console.error("Error accessing index:", error);
          reject(error);
        }
      };
    });
  }
  async getFileLineDataMap(filePath) {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      request.onerror = (event) => {
        console.error("Database error:", event.target.error);
        reject(event.target.error);
      };
      request.onsuccess = (event) => {
        const db = event.target.result;
        console.log("this.dbName", this.dbName);
        const transaction = db.transaction("file-line-index", "readonly");
        const store = transaction.objectStore("file-line-index");
        try {
          const index = store.index("filePath");
          const query = index.getAll(filePath);
          query.onsuccess = () => {
            const lineDataMap = /* @__PURE__ */ new Map();
            query.result.forEach((item) => {
              lineDataMap.set(item.content, item);
            });
            resolve(lineDataMap);
          };
          query.onerror = (event2) => {
            console.error("Query error:", event2.target.error);
            reject(event2.target.error);
          };
        } catch (error) {
          console.error("Error accessing index:", error);
          reject(error);
        }
      };
    });
  }
  async addRowFolder(rowData) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(TABLE_FOLDER_TIME_INDEX, "readwrite");
      const store = transaction.objectStore(TABLE_FOLDER_TIME_INDEX);
      const request = store.add(rowData);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  async updateRowFolderIndex(rowData) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(TABLE_FOLDER_TIME_INDEX, "readwrite");
      const store = transaction.objectStore(TABLE_FOLDER_TIME_INDEX);
      const request = store.put(rowData);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  async deleteRowFolderIndex(id) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(TABLE_FOLDER_TIME_INDEX, "readwrite");
      const store = transaction.objectStore(TABLE_FOLDER_TIME_INDEX);
      const request = store.delete(id);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  async getMemories(dateNo) {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      request.onerror = (event) => {
        console.error("Database error:", event.target.error);
        reject(event.target.error);
      };
      request.onsuccess = (event) => {
        const db = event.target.result;
        const transaction = db.transaction(TABLE_NOTES, "readonly");
        const store = transaction.objectStore(TABLE_NOTES);
        try {
          const index = store.index("dateNo");
          const query = index.getAll(dateNo);
          query.onsuccess = () => {
            const notes = query.result;
            notes.sort((a, b) => b.createdDate.getTime() - a.createdDate.getTime());
            resolve(notes);
          };
          query.onerror = (event2) => {
            console.error("Query error:", event2.target.error);
            reject(event2.target.error);
          };
        } catch (error) {
          console.error("Error accessing index:", error);
          reject(error);
        }
      };
    });
  }
};

// views/MemoriesListView.ts
var MEMORIES_VIEW_TYPE = "memories-list-view";
var MEMORIES_TEXT = "List Memories";
var CSS_STYLE = `

.memories-view-container {
	background-color: #ccc;
	height: 100%;
	overflow-y: auto;
}
.timeline {
	margin: 0 200px;
	padding: 20px 0; 
}

.events-container {
	background-color: white;
	padding: 10px;
	border-radius: 5px;
}

.year-title {
	background-color: #ccc;
	color: #605e5e;
	padding: 20px;
	text-align: left;
	margin: 0;
	font-weight: bold;
	font-size: 1.5em;
}

.event {
	position: relative;
	padding: 10px 0;
	background-color: white;
}

.event:last-child {
	.event-content {
		margin-bottom: none;
	}
}

.event-date {
	position: absolute;
	left: 10px;
	top: 50%;
	transform: translateY(-50%);
	color: #373737;
	width: 100px;
	text-align: center;
	border-radius: 10px;
	font-size: 0.9em;
}


.event-content {
	border-bottom: 1px solid #ddd;
	margin-left: 120px;
	padding-bottom: 15px;
}
.event-title {
	font-weight: normal;
	color: #1c7ad6; 
	cursor: pointer;
	text-align: right;
	display: block;
}

.event-description {
	margin-top: 5px;
	color: #403f3f;
	font-size: 1em;
}

.status {
	position: absolute;
	right: 10px;
	top: 10px;
	background-color: #007bff;
	color: white;
	padding: 2px 8px;
	border-radius: 4px;
	font-size: 0.8em;
}

.timeline-header {
    display: flex;
    justify-content: flex-end;
    padding: 20px 0px;
   margin: 0 200px;
}

.timeline-header #search-box {
    padding: 7px 10px;
    margin: 0px 5px;
    border: 1px solid #ddd;
    border-radius: 5px;
    height: 40px; 
    width: 300px; 
	background-color: #fff;
	box-shadow: #fff;
	text-color: #605e5e;
}

.timeline-header #search-btn {
    padding: 8px 15px;
    border-radius: 5px;
    background-color: #007bff;
    color: white;
    border: none;
    height: 40px;  
    width: 100px;
	margin: 0px 5px;
} 

@media screen and (max-width: 768px) {
	.timeline {
		margin: 0 10px;
		padding: 20px 5px;
	}

	.event-date {
		left: 5px;
		width: 90px;
		font-size: 0.9em;

		.event-content {
			margin-left: 100px;
		}

		.status {
			right: 5px;
			font-size: 0.7em;
		}
	}
	.timeline-header {
        margin: 0 10px;  
        justify-content: center;
        flex-direction: column;
    }

    .timeline-header #search-box {
        width: calc(100% - 20px); 
        margin: 5px 5px;  
    }

    .timeline-header #search-btn {
        width: calc(100% - 20px); 
        margin-bottom: 5px;
    }
`;
var MemoriesView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin, app) {
    super(leaf);
    this.plugin = plugin;
    this.utils = new MemoryLaneUtils(plugin);
    this.app = app;
    this.dbManager = new IndexedDBManager();
    this.initialize();
  }
  async initialize() {
    await this.dbManager.openDatabase();
  }
  getViewType() {
    return MEMORIES_VIEW_TYPE;
  }
  getDisplayText() {
    return MEMORIES_TEXT;
  }
  async onOpen() {
    const { containerEl } = this;
    this.addStyles();
    containerEl.empty();
    this.renderSearch(containerEl);
    this.renderNotes(containerEl);
  }
  renderSearch(containerEl, searchValue = "") {
    let searchText = "Search notes...";
    if (searchValue) {
      searchText = searchValue;
    }
    containerEl.addClass("memories-view-container");
    const searchContainer = containerEl.createDiv("timeline-header");
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      attr: { id: "search-box" },
      placeholder: searchText,
      value: searchValue
    });
    const searchButton = searchContainer.createEl("button", {
      text: "Search",
      attr: { id: "search-btn" }
    });
    searchButton.addEventListener("click", () => {
      const searchTerm = searchInput.value;
      containerEl.empty();
      this.renderSearch(containerEl, searchTerm);
      this.renderNotes(containerEl, searchTerm);
    });
    const searchAllButton = searchContainer.createEl("button", {
      text: "All Data",
      attr: { id: "search-btn" }
    });
    searchAllButton.addEventListener("click", () => {
      const searchTerm = "";
      containerEl.empty();
      this.renderSearch(containerEl, searchTerm);
      this.renderNotes(containerEl, searchTerm);
    });
    searchInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        const searchTerm = searchInput.value;
        containerEl.empty();
        this.renderSearch(containerEl, searchTerm);
        this.renderNotes(containerEl, searchTerm);
      }
    });
  }
  async renderNotes(containerEl, searchValue = "") {
    let allNotes = [];
    console.log("searchValue", searchValue);
    if (searchValue)
      allNotes = await this.dbManager.getAllData(searchValue, "desc");
    else {
      const folderTimeObj = await this.dbManager.getFolderLastModify(
        this.plugin.settings.folderPath,
        this.plugin.settings.tagName
      );
      console.log("folderTimeObj", folderTimeObj);
      let notesInFolder = null;
      if (folderTimeObj == null || !folderTimeObj) {
        notesInFolder = await this.utils.getNotesInFolder(
          this.plugin.settings.folderPath,
          this.app
        );
        const folderTimeIndex = {
          id: 0,
          folderPath: this.plugin.settings.folderPath,
          hashtag: this.plugin.settings.tagName,
          lastModified: new Date()
        };
        console.log("folderTimeIndex", folderTimeIndex);
        this.dbManager.addRowFolder(folderTimeIndex);
      } else {
        const lastModify = new Date(folderTimeObj == null ? void 0 : folderTimeObj.lastModified);
        console.log("lastModify", lastModify);
        notesInFolder = await this.utils.getNotesInFolderWithLastModify(
          this.plugin.settings.folderPath,
          lastModify,
          this.app
        );
      }
      console.log("notesInFolder", notesInFolder);
      for (const fileNote of notesInFolder) {
        const fileContent = await this.app.vault.read(fileNote);
        const filePath = this.plugin.settings.folderPath + "/" + fileNote.basename;
        try {
          await this.utils.processFileContent(
            this.dbManager,
            fileNote,
            fileContent,
            this.plugin.settings.tagName,
            filePath
          );
        } catch (error) {
          console.error("Error processing file content:", error);
        }
      }
      allNotes = await this.dbManager.getAllData(null, "desc");
      console.log("allNotes", allNotes);
    }
    const contentContainer = containerEl.createDiv(
      "memories-view-container"
    );
    const timelineContainer = contentContainer.createDiv("timeline");
    if (allNotes.length == 0) {
      timelineContainer.createEl("div", {
        cls: "event",
        text: "No notes found"
      });
      return;
    }
    const groupedNotes = this.utils.groupNotesByYear(allNotes);
    console.log(groupedNotes);
    const sortedYears = this.utils.sortGroupedNotes(groupedNotes);
    for (const year in sortedYears) {
      const yearTitle = timelineContainer.createEl("div", {
        cls: "year-title"
      });
      yearTitle.textContent = year;
      const eventsContainer = timelineContainer.createDiv("events-container");
      const notesInYear = sortedYears[year];
      notesInYear.forEach((currentNote) => {
        const note = currentNote;
        const eventDiv = eventsContainer.createDiv("event");
        const eventDate = eventDiv.createDiv("event-date");
        if (note.fileCreatedDate === note.rowCreatedDate) {
          eventDate.textContent = this.utils.formatDate(note.fileCreatedDate, this.plugin.settings.dateFormat);
        } else {
          eventDate.textContent = this.utils.formatDate(note.rowCreatedDate, this.plugin.settings.dateFormat);
        }
        const eventContent = eventDiv.createDiv("event-content");
        eventContent.createEl("div", {
          cls: "event-description",
          text: note.rowContent
        });
        const eventTitle = eventContent.createEl("div", {
          cls: "event-title"
        });
        eventTitle.textContent = note.fileName;
        eventTitle.addEventListener("click", async () => {
          const fileNameWithExtension = note.fileName.endsWith(".md") ? note.fileName : `${note.fileName}.md`;
          const file = this.app.vault.getAbstractFileByPath(
            fileNameWithExtension
          );
          if (file instanceof import_obsidian2.TFile) {
            const newLeaf = this.app.workspace.getLeaf();
            await newLeaf.openFile(file);
          } else {
            console.error("File not found:", fileNameWithExtension);
          }
        });
      });
    }
  }
  async onClose() {
    const styles = document.head.querySelectorAll("style");
    styles.forEach((styleEl) => {
      if (styleEl.innerHTML.includes(CSS_STYLE)) {
        document.head.removeChild(styleEl);
      }
    });
  }
  async onLoadState(state) {
    console.log("onLoadState", state);
    if (state.markdownContent) {
      this.markdownContent = state.markdownContent;
    }
  }
  addStyles() {
    const styleEl = document.createElement("style");
    styleEl.type = "text/css";
    styleEl.innerHTML = CSS_STYLE;
    document.head.appendChild(styleEl);
  }
};

// views/MemoryLaneSettingsTab.ts
var import_obsidian3 = require("obsidian");
var MemoryLaneSettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.initializeDefaultSettings();
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const folders = this.getFolders(this.app);
    new import_obsidian3.Setting(containerEl).setName("Folder Path").setDesc("Path of the folder to monitor").addDropdown((dropdown) => {
      folders.forEach((folder) => {
        dropdown.addOption(folder, folder);
      });
      dropdown.setValue(this.plugin.settings.folderPath);
      dropdown.onChange(async (value) => {
        this.plugin.settings.folderPath = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Tag Name").setDesc("Name of the tag to filter notes").addText(
      (text) => text.setPlaceholder("Enter tag name").setValue(this.plugin.settings.tagName).onChange(async (value) => {
        this.plugin.settings.tagName = value;
        await this.plugin.saveSettings();
      })
    );
    const mySetting = new import_obsidian3.Setting(containerEl).setName("Date Format").setDesc("The display date format, default is yyyy-mm-dd.").addText(
      (text) => text.setPlaceholder("Enter date format").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
        this.plugin.settings.dateFormat = value;
        await this.plugin.saveSettings();
      })
    );
    const linkDesc = document.createElement("span");
    linkDesc.innerHTML = ' See formatting at <a href="https://moment.github.io/luxon/#/formatting?id=table-of-tokens" target="_blank">here</a>.';
    mySetting.descEl.appendChild(linkDesc);
  }
  getFolders(app) {
    return app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian3.TFolder).map((folder) => folder.path);
  }
  initializeDefaultSettings() {
    if (!this.plugin.settings.dateFormat) {
      this.plugin.settings.dateFormat = "yyyy-MM-dd";
    }
  }
};

// main.ts
var import_obsidian5 = require("obsidian");

// views/MemoriesDay.ts
var import_obsidian4 = require("obsidian");
var MEMORIES_DAY_TYPE = "memories-day-view";
var MEMORIES_DAY_TEXT = "Memories Day";
var CSS_STYLE2 = `
.memories-view-container {
	background-color: #ccc;
	height: 100%;
	overflow-y: auto;
}
.timeline {
	margin: 0 200px;
	padding: 20px 0; 
}

.events-container {
	background-color: white;
	padding: 10px;
	border-radius: 5px;
}

.year-title {
	background-color: #ccc;
	color: #605e5e;
	padding: 20px;
	text-align: left;
	margin: 0;
	font-weight: bold;
	font-size: 1.5em;
}

.event {
	position: relative;
	padding: 10px 0;
	background-color: white;
}

.event:last-child {
	.event-content {
		margin-bottom: none;
	}
}

.event-date {
	position: absolute;
	left: 10px;
	top: 50%;
	transform: translateY(-50%);
	color: #373737;
	width: 100px;
	text-align: center;
	border-radius: 10px;
	font-size: 0.9em;
}


.event-content {
	border-bottom: 1px solid #ddd;
	margin-left: 120px;
	padding-bottom: 15px;
}
.event-title {
	font-weight: normal;
	color: #1c7ad6; 
	cursor: pointer;
	text-align: right;
	display: block;
}

.event-description {
	margin-top: 5px;
	color: #403f3f;
	font-size: 1em;
}

.status {
	position: absolute;
	right: 10px;
	top: 10px;
	background-color: #007bff;
	color: white;
	padding: 2px 8px;
	border-radius: 4px;
	font-size: 0.8em;
}

.timeline-header {
    display: flex;
    justify-content: flex-end;
    padding: 20px 0px;
   margin: 0 200px;
}

.timeline-header #search-box {
    padding: 7px 10px;
    margin: 0px 5px;
    border: 1px solid #ddd;
    border-radius: 5px;
    height: 40px; 
    width: 300px; 
	background-color: #fff;
	box-shadow: #fff;
	text-color: #605e5e;
}

.timeline-header #search-btn {
    padding: 8px 15px;
    border-radius: 5px;
    background-color: #007bff;
    color: white;
    border: none;
    height: 40px;  
    width: 100px;
	margin: 0px 5px;
} 

@media screen and (max-width: 768px) {
	.timeline {
		margin: 0 10px;
		padding: 20px 5px;
	}

	.event-date {
		left: 5px;
		width: 90px;
		font-size: 0.9em;

		.event-content {
			margin-left: 100px;
		}

		.status {
			right: 5px;
			font-size: 0.7em;
		}
	}
	.timeline-header {
        margin: 0 10px;  
        justify-content: center;
        flex-direction: column;
    }

    .timeline-header #search-box {
        width: calc(100% - 20px); 
        margin: 5px 5px;  
    }

    .timeline-header #search-btn {
        width: calc(100% - 20px); 
        margin-bottom: 5px;
    }
`;
var MemoriesDay = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin, app) {
    super(leaf);
    this.plugin = plugin;
    this.utils = new MemoryLaneUtils(plugin);
    this.app = app;
    this.dbManager = new IndexedDBManager();
    this.initialize();
  }
  async initialize() {
    await this.dbManager.openDatabase();
  }
  getViewType() {
    return MEMORIES_DAY_TYPE;
  }
  getDisplayText() {
    return MEMORIES_DAY_TEXT;
  }
  async onOpen() {
    const { containerEl } = this;
    this.addStyles();
    containerEl.empty();
    console.log("start memories day");
    this.renderNotes(containerEl);
  }
  async renderNotes(containerEl) {
    const dateNo = this.utils.getMMDD(new Date());
    const allNotes = await this.dbManager.getMemories(dateNo);
    console.log("allNotes", allNotes);
    const contentContainer = containerEl.createDiv(
      "memories-view-container"
    );
    const timelineContainer = contentContainer.createDiv("timeline");
    if (allNotes === null || allNotes.length === 0) {
      timelineContainer.createEl("div", {
        cls: "event",
        text: "No notes found"
      });
      return;
    }
    const groupedNotes = this.utils.groupNotesByYear(allNotes);
    console.log(groupedNotes);
    const sortedYears = this.utils.sortGroupedNotes(groupedNotes);
    for (const year in sortedYears) {
      const yearTitle = timelineContainer.createEl("div", {
        cls: "year-title"
      });
      yearTitle.textContent = year;
      const eventsContainer = timelineContainer.createDiv("events-container");
      const notesInYear = sortedYears[year];
      notesInYear.forEach((currentNote) => {
        const note = currentNote;
        const eventDiv = eventsContainer.createDiv("event");
        const eventDate = eventDiv.createDiv("event-date");
        if (note.fileCreatedDate === note.rowCreatedDate) {
          eventDate.textContent = note.fileCreatedDate.toDateString();
        } else {
          eventDate.textContent = note.rowCreatedDate.toDateString();
        }
        const eventContent = eventDiv.createDiv("event-content");
        eventContent.createEl("div", {
          cls: "event-description",
          text: note.rowContent
        });
        const eventTitle = eventContent.createEl("div", {
          cls: "event-title"
        });
        eventTitle.textContent = note.fileName;
        eventTitle.addEventListener("click", async () => {
          const fileNameWithExtension = note.fileName.endsWith(".md") ? note.fileName : `${note.fileName}.md`;
          const file = this.app.vault.getAbstractFileByPath(
            fileNameWithExtension
          );
          if (file instanceof import_obsidian4.TFile) {
            const newLeaf = this.app.workspace.getLeaf();
            await newLeaf.openFile(file);
          } else {
            console.error("File not found:", fileNameWithExtension);
          }
        });
      });
    }
  }
  async onClose() {
    const styles = document.head.querySelectorAll("style");
    styles.forEach((styleEl) => {
      if (styleEl.innerHTML.includes(CSS_STYLE2)) {
        document.head.removeChild(styleEl);
      }
    });
  }
  addStyles() {
    const styleEl = document.createElement("style");
    styleEl.type = "text/css";
    styleEl.innerHTML = CSS_STYLE2;
    document.head.appendChild(styleEl);
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  folderPath: "",
  tagName: "",
  dateFormat: ""
};
var MemoryLanePlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.taggedNotes = [];
    this.processedFolderFiles = {};
  }
  async onload() {
    await this.loadSettings();
    this.processedFolderFiles = await this.loadData() || {};
    this.utils = new MemoryLaneUtils(this);
    this.addRibbonIcon("brain-circuit", "MemoryLane", async () => {
      this.openMemoriesListView();
    });
    this.addSettingTab(new MemoryLaneSettingsTab(this.app, this));
    this.registerView(
      MEMORIES_VIEW_TYPE,
      (leaf) => new MemoriesView(leaf, this, this.app)
    );
    this.addCommand({
      id: "open-memories-list-view",
      name: "Open Memories List",
      callback: () => this.openMemoriesListView()
    });
    this.registerView(
      MEMORIES_DAY_TYPE,
      (leaf) => new MemoriesDay(leaf, this, this.app)
    );
    this.addCommand({
      id: "open-memories-day-view",
      name: "Open Memories Day",
      callback: () => this.openMemoriesDayView()
    });
  }
  onunload() {
    console.log("unloading plugin");
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveProcessedFolderFiles() {
    await this.saveData(this.processedFolderFiles);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async openMemoriesListView() {
    let found = false;
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType() === MEMORIES_VIEW_TYPE) {
        this.app.workspace.revealLeaf(leaf);
        found = true;
        return false;
      }
    });
    if (!found) {
      const leaf = this.app.workspace.getLeaf(true);
      await leaf.setViewState({
        type: MEMORIES_VIEW_TYPE,
        state: { markdownContent: "" }
      });
      this.app.workspace.revealLeaf(leaf);
    }
  }
  async openMemoriesDayView() {
    console.log("openMemoriesDayView");
    let found = false;
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType() === MEMORIES_DAY_TYPE) {
        this.app.workspace.revealLeaf(leaf);
        found = true;
        return false;
      }
    });
    if (!found) {
      const leaf = this.app.workspace.getLeaf(true);
      await leaf.setViewState({
        type: MEMORIES_DAY_TYPE,
        state: { markdownContent: "" }
      });
      this.app.workspace.revealLeaf(leaf);
    }
  }
};
